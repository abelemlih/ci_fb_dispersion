---
title: "SocialNetworksActivity"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(jsonlite)
library(dplyr)
library(purrr)
```

### Collect Data

Get data from https://lostcircles.com/. Download JSON(no pics) after up finish loading your network. Run the following function to get a adjacency list. One thing about the json file is that some edges only have one directions recorded but we should add both directions to the adj list.

```{r}
data <- fromJSON("fb_network.json")
nodes <- data$nodes
links <- data$links
```

```{r}
nodes <- nodes %>%
  mutate(node = 0:(nrow(nodes)-1)) %>%
  select(node, name)
```

```{r}
map_neighbors <- function(data, node) {
  neighbors <- data %>%
    filter(source == node | target == node)
  neighbors <- unique(c(neighbors$source, neighbors$target))
  neighbors[neighbors != node]
}

common_neighbors <- function(data, node1, node2) {
  intersect(map_neighbors(data, node1), map_neighbors(data, node2))
}

distance <- function(data, node1, node2, threshold = 1) {
  #no common neighbors between the vertices node1 and node2
  #cn <- common_neighbors(data, node1, node2)
  #if(length(cn) > 2) return(0)
  ifelse(node1 %in% map_neighbors(data, node2), 0, 1)
}

dispersion <- function(data, u, v, normalized = FALSE) {
  cn <- data %>% common_neighbors(u, v) 
  if(length(cn) <= 1) return(0)
  
  result <- 0
  for(i in 1:(length(cn)-1)) {
    for(j in (i+1):length(cn)) {
      result <- result + distance(data, cn[i], cn[j])
    }
  }
  if(normalized) return(result/length(cn))
  result
}
```

```{r}
tdata <- read.csv("testing_graph.csv", header = TRUE, stringsAsFactors = FALSE)
tdata %>% distance('c', 'j')
tdata %>% distance('c', 'f')
tdata %>% dispersion('u', 'h')
tdata %>% dispersion('u', 'b')
```

```{r, cache=TRUE}
rdisp <- function(data, disp, u, v) {
  cn <- common_neighbors(data, u, v)
  if(length(cn)<=1) return(0)
  
  result <- 0
  for (i in 1:length(cn)) {
    result <- result + (disp[cn[i]+1, length(disp)])^2
  }
  
  for(i in 1:(length(cn)-1)) {
    for(j in (i+1):length(cn)) {
      p <- c(disp[cn[i]+1, length(disp)], disp[cn[j]+1, length(disp)]) %>% prod()
      result <- result + 2*p*distance(data, cn[i], cn[j])
    }
  }
  result/length(cn)
}

recursive_dispersion <- function(data, u, max_iter = 1) {
  disp <- data.frame(node1 = u, node2 = nodes$node, it0 = 1)
  for (i in 1:max_iter) {
    new_iter <- c()
    for (j in disp$node2) {
      new_iter <- c(new_iter, rdisp(data, disp, disp[1,1], disp[j+1, 2]))
    }
    disp[paste('iter', i, sep = '')] <- new_iter
  }
  disp
}


df <- links %>% recursive_dispersion(11, max_iter = 1)
```

